CREATE TABLE TEMP_DEPT
AS SELECT * FROM DEPARTMENT WHERE 1 = 0;

-- 그냥 넣기
INSERT INTO TEMP_DEPT VALUES('D1', '자바학부', '1');
-- 컬럼 지정해서 넣기
INSERT INTO TEMP_DEPT (DEPT_ID, DEPT_TITLE, LOCATION_ID) VALUES('D2','메가스터디', '1');

SELECT * FROM TEMP_DEPT;

CREATE TABLE TEST_TAB(
    TEST_NAME VARCHAR2(20) DEFAULT '없음' NOT NULL,
    TEST_NUM NUMBER
);

-- DEFAULT 값 있으면 다 안넣어줘도 됨
INSERT INTO TEST_TAB (TEST_NUM) VALUES(100);
SELECT * FROM TEST_TAB;

-- JOIN INSERT
CREATE TABLE INSERT_SUB
AS SELECT EMP_ID, EMP_NAME, DEPT_TITLE
   FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID WHERE 1=0;
   
INSERT INTO INSERT_SUB(SELECT EMP_ID, EMP_NAME, DEPT_TITLE 
                        FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
                        WHERE DEPT_CODE = 'D5');

SELECT * FROM INSERT_SUB;

-- INSERT ALL
-- 서브쿼리를 이용해서 두개 이상의 테이블에 데이터를 삽입하는 명령어

CREATE TABLE EMP_HIRE_DATE
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE;
DELETE FROM EMP_HIRE_DATE;

CREATE TABLE EMP_MANAGER2
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID FROM EMPLOYEE WHERE 1=0;

INSERT ALL
INTO EMP_HIRE_DATE VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
INTO EMP_MANAGER2 VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, MANAGER_ID
FROM EMPLOYEE;

SELECT * FROM EMP_HIRE_DATE;
SELECT * FROM EMP_MANAGER2;

-- INSERT ALL 을 이용해서 테이블에 값을 넣을때 조건에 맞춰 넣기
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1= 0;
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1 = 0;

-- EMP_OLD 테이블에 00년 01월 01일 이전에 입사한 사원들의 데이터를 삽입
-- EMP_NEW 테이블에 00년 01월 01일 이후에 입사한 사원들의 데이터를 삽입

INSERT ALL
    WHEN '00/01/01' > HIRE_DATE THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
    WHEN '00/01/01' <= HIRE_DATE THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

-- UPDATE 활용하기
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY, BONUS
FROM EMPLOYEE;

-- WHERE 절 없으니까 다 바뀜 ㅋㅋ
UPDATE EMP_SALARY SET SALARY = 3000000;


ROLLBACK; --트랜잭션

UPDATE EMP_SALARY SET BONUS = 0.2 WHERE BONUS IS NULL;

-- 서브쿼리로 UPDATE

UPDATE EMP_SALARY SET (SALARY, BONUS) = (SELECT SALARY, BONUS FROM EMPLOYEE WHERE EMP_ID=200)
WHERE DEPT_CODE IS NULL;

-- UPDATE 문에서 함수사용
UPDATE EMP_SALARY SET SALARY = LENGTH('ASDASDASDASDASD');

ROLLBACK;

SELECT * FROM EMP_SALARY;

-- TRUNCATE
-- 테이블에 있는 데이터를 삭제하는 구문 전체삭제 속도가 빠름
-- 복원불가능
TRUNCATE TABLE EMP_SALARY;
SELECT * FROM EMP_SALARY;
ROLLBACK;


-- 트랜잭션 처리하는 명령어
-- 트랜잭션 : 한개의 작업단위, 데이터를 조작하는 작업의 단위
-- 한개 서비스에서 데이터를 조작(삽입,수정,삭제) 하는 명령어가 여러개이면 관리를 해줘야한다
-- 저장, 취소할지 결정 할 수 있다. -> COMMIT , ROLLBACK 으로
-- 지금까지으 ㅣ작업을 저장하려면 COMMIT 을 수행
-- 지금까지의 작업을 모두 취소하려면 ROLLBACK
-- 작업 (DML 이 대상임)

SELECT * FROM TEMP_DEPT;
INSERT INTO TEMP_DEPT VALUES('D3', 'COMMIT전', 'L4');
COMMIT;


-- ALERT ,DROP 오브젝트를 수정,삭제 하는 명령어




-- 오라클이 제공하는 오브젝트에 대해 알아보자
-- VIEW, SEQUENCE
-- VIEW 가상의 테이블 실제 존재하지 않는 테이블
-- RESULT SET(SELECT문)으로 만든 가상테이블 -> 실제 테이블 기반으로 생성한다.
-- VIEW -> 여러가지 가상 컬렁믈 사용하는 테이블을 이용할 때
-- 별도의 생성권한이 필요함
GRANT CREATE VIEW TO BS;

CREATE VIEW V_EMP_DEPT
AS SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT * FROM V_EMP_DEPT;

SELECT EMP_NAME, DEPT_TITLE, SALARY
FROM V_EMP_DEPT;

-- 각 분야별 월급의 평균
SELECT DEPT_CODE, FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY DEPT_CODE;
SELECT JOB_CODE, FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY JOB_CODE;

CREATE VIEW V_AVG_TYPE
AS 
SELECT DEPT_CODE AS TYPE, FLOOR(AVG(SALARY)) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_CODE
UNION
SELECT JOB_CODE, FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT * FROM V_AVG_TYPE;

-- 1. VIEW 테이블 생성시에 설정한 컬럼만 사용할 수 있음.
-- 2. VIEW 테이블은 데이터를 조회하기 위한 용도로 DML 구문은 VIEW 테이블로 일반적으로 사용하진 않음

-- 생성된 VIEW 테이블 조회하기
SELECT * FROM USER_VIEWS;


-- 오라클에서 제공하는 시퀀스 사용

CREATE SEQUENCE SEQ_BASIC;

SELECT SEQ_BASIC.NEXTVAL FROM DUAL;
INSERT INTO BOARD VALUES(SEQ_BASIC.NEXTVAL, '3번째글', '나의 3번째 글','ADMIN', SYSDATE);

SELECT * FROM BOARD;

-- 현재 발급된 번호를 확인
SELECT SEQ_BASIC.CURRVAL FROM DUAL;

-- 옵션을 설정해서 생성 할 수 있다.
-- START WITH : 생성번호가 설정한 숫자부터 시작 DEFAULT 1
-- INCREMENT BY 숫자 : 번호 증가 간격 DEFAULT 1
-- MAXVALUE : 증가번호의 최대값
-- MINVALUE : 증가번호의 최소값
-- CYCLE/NO : 번호를 순환할지 결정
-- CACHE : 미리 번호를 생성해놓는것

CREATE SEQUENCE SEQ_01
START WITH 100
INCREMENT BY 5;

SELECT SEQ_01.NEXTVAL FROM DUAL;


CREATE SEQUENCE SEQ_TEST;
SELECT SEQ_TEST.NEXTVAL FROM DUAL;
SELECT SEQ_TEST.CURRVAL FROM DUAL;  

-- 계층형 쿼리 (오라클에서만 제공)
-- ROW를 구조에 맞춰서 순서대로 가져오는 것

SELECT LEVEL, EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE
    START WITH EMP_ID = 200
    CONNECT BY PRIOR EMP_ID = MANAGER_ID;